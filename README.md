## 실전! 스프링 부트와 JPA 활용 코드
김영한님의 인프런 강의  
[강의 링크](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-JPA-%ED%99%9C%EC%9A%A9-1/)  
[로드맵 링크](https://www.inflearn.com/roadmaps/149)

### 강의와 다른 점
- Junit4 -> Junit5 사용  
기존에 Junit4를 사용해본 적이 없고 Junit5로 테스트를 진행했었기 때문에 더 익숙하고 최신 버전인 Junit5로 테스트 코드를 작성하기로 결정
  
### 사용 기술 스택 / 프레임워크 / 라이브러리
- Java 11
- SpringBoot 2.4.2
- Gradle
- Junit 5
- h2 database

### Note
강의를 들으면서 메모할 부분들

#### 연관 관계  
연관 관계에는 일대다, 다대일, 다대다 관계가 있으며 단방향과 양방향 관계가 존재한다. 이 중 다대다 관계는 관계형 데이터베이스는 물론이고 엔티티에서도 거의 사용하지 않는다.
따라서 다대다 관계의 가운데에 엔티티를 추가해서 다대다 관계를 다대일, 일대다 관계로 풀어낸다.

**연관 관계의 주인**  
연관 관계의 주인은 비즈니스 상 우위에 있다고 정하면 안된다. 연관관계의 문제는 단순히 외래 키를 누가 관리하느냐의 문제다.
일대다 연관관계에서 일 쪽에 연관 관계의 주인으로 정하면 유지 보수가 어렵고 별도의 업데이트 쿼리가 발생하는 성능 문제가 있다.

#### 엔티티 클래스 개발

**엔티티의 Setter 사용을 지양할 것**  
이론적으로는 Getter, Setter 모두 사용하지 않고 별도의 메소드를 사용하는 것이 이상적이다.
하지만 Getter는 쓸 상황이 많고, 사용한다고 엔티티가 변하지 않으니 사용하는 것이 편리하다.
그러나 Setter를 호출하면 데이터가 변한다. Setter를 막 열어두면 엔티티가 왜 변경되는지 추적하기 점점 힘들어진다.
따라서 엔티티의 변경 지점이 명확한 별도의 비즈니스 메소드를 작성한다.

예제에서는 편리함을 위해 Setter를 사용했지만, 이번 학습에서는 Setter 대신 builder 패턴을 사용하고, 
중간에 엔티티의 값이 변경되어야 하는 로직은 별도의 비즈니스 메소드를 작성해서 Setter의 사용을 지양하도록 한다.

builder 패턴을 사용할 때는 lombok @Builder를 사용한다. 이 때, @NoArgsConstructor 와 @AllArgsConstructor를 사용한다.
@NoArgsConstructor는 접근 제한을 protected로 걸어서 혹시 모를 빈 객체 생성을 방지한다.

**상속 관계 매핑**  
관계형 데이터베이스에는 상속이라는 개념이 없다. 대신 슈퍼타입 서브타입 관계라는 유사한 모델링 기법이 있다.
슈퍼타입 서브타임 관계를 테이블로 구현할 때는 세 가지 방식을 사용할 수 있다. (다음의 세 가지 전략의 이름은 JPA에서 지칭하는 이름이다.)
- 조인 전략: 각각을 테이블로 만들고 조회할 때 조인한다.
- 단일 테이블 전략: 슈퍼타입 테이블이 서브타입 테이블의 필드를 모두 가진다.
- 구현 클래스마다 테이블 전략: 서브타입 테이블만 만든다. 설계 전문가와 ORM 전문가 모두 추천하지 않는 방식이다.

이 예제에서는 Item을 상속받는 Album, Book, Movie를 구현할 때 단일 테이블 전략을 사용하기로 한다.
단일 테이블 전략에서는 슈퍼타입에 @DiscriminatorColumn(name = "DTYPE") 어노테이션을 사용하여 매핑해주고,
서브타입에는 @DiscriminatorValue("XXX")를 사용해서 매핑한다.

**모든 연관관계는 지연로딩으로 설정**  
즉시로딩(Eager)는 예측이 어렵고, 어떤 SQL이 실행될지 추적이 어렵다.
모든 연관관계가 EAGER로 설정되어 있으면 필요없는 연관관계까지 모두 끌어오게 되고, JPQL을 사용할 떄 N+1 문제가 발생한다.
따라서 실무에서는 EAGER를 사용하지 않고 모든 연관관계를 지연로딩(LAZY)으로 설정한다.
연관된 엔티티를 함께 조회해야 할 때는 fetch join이나 엔티티 그래프를 이용한다.

OneToMany는 기본 fetch 전략이 LAZY로 되어 있지만, XToOne은 기본 fetch 전략이 EAGER로 되어 있어 직접 설정해야 한다.

**컬렉션은 필드에서 바로 초기화**  
컬렉션은 필드에서 바로 초기화 하는 것이 null 문제에서도 안전하고, 하이버네이트 영속화 시에 안전하다.
하이버네이트는 엔티티를 영속화 할 떄 하이버네이트가 제공하는 내장 컬렉션으로 감싸서 변경하기 때문에,
임의의 메소드에서 컬렉션을 잘못 생성하면 하이버네이트 내부 메커니즘에 문제가 발생할 수 있다.
따라서 필드를 선언할 때 바로 초기화 하는것이 안전하고 코드도 간결하다.

코드 내에서 컬렉션을 꺼내서 Setter 등으로 수정되지만 않으면 되므로, 이번 예제를 공부하면서 컬렉션은 모두 final로 선언하기로 한다.
실제로 엔티티 내의 컬렉션들은 필드 레벨에서 초기화 했을 때 final로 선언하라는 경고 메시지가 뜬다.

**Cascade**  
cascade 옵션은 엔티티의 영속성을 전이시키는 옵션이다. 영속성 전이의 종류로는 ALL, PERSIST, DETACH, REFRESH, MERGE, REMOVE등이 있다.
이 예제에서 사용하는 CascadeType.ALL 옵션을 넣어주면 모든 cascade 옵션이 적용되어 엔티티의 영속화, 병합, 새로고침, 삭제, detatch()가 해당 엔티티의 필드에 보유된 엔티티에도 적용된다.

