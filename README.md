## 실전! 스프링 부트와 JPA 활용 코드
김영한님의 인프런 강의  
[강의 링크](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-JPA-%ED%99%9C%EC%9A%A9-1/)  
[로드맵 링크](https://www.inflearn.com/roadmaps/149)

### 강의와 다른 점
- Junit4 -> Junit5 사용  
기존에 Junit4를 사용해본 적이 없고 Junit5로 테스트를 진행했었기 때문에 더 익숙하고 최신 버전인 Junit5로 테스트 코드를 작성하기로 결정
  
### 사용 기술 스택 / 프레임워크 / 라이브러리
- Java 11
- SpringBoot 2.4.2
- Gradle
- Junit 5
- h2 database

### Note
강의를 들으면서 메모할 부분들

#### 연관 관계  
연관 관계에는 일대다, 다대일, 다대다 관계가 있으며 단방향과 양방향 관계가 존재한다. 이 중 다대다 관계는 관계형 데이터베이스는 물론이고 엔티티에서도 거의 사용하지 않는다.
따라서 다대다 관계의 가운데에 엔티티를 추가해서 다대다 관계를 다대일, 일대다 관계로 풀어낸다.

**연관 관계의 주인**  
연관 관계의 주인은 비즈니스 상 우위에 있다고 정하면 안된다. 연관관계의 문제는 단순히 외래 키를 누가 관리하느냐의 문제다.
일대다 연관관계에서 일 쪽에 연관 관계의 주인으로 정하면 유지 보수가 어렵고 별도의 업데이트 쿼리가 발생하는 성능 문제가 있다.

#### 엔티티 클래스 개발

**엔티티의 Setter 사용을 지양할 것**  
이론적으로는 Getter, Setter 모두 사용하지 않고 별도의 메소드를 사용하는 것이 이상적이다.
하지만 Getter는 쓸 상황이 많고, 사용한다고 엔티티가 변하지 않으니 사용하는 것이 편리하다.
그러나 Setter를 호출하면 데이터가 변한다. Setter를 막 열어두면 엔티티가 왜 변경되는지 추적하기 점점 힘들어진다.
따라서 엔티티의 변경 지점이 명확한 별도의 비즈니스 메소드를 작성한다.

예제에서는 편리함을 위해 Setter를 사용했지만, 이번 학습에서는 Setter 대신 builder 패턴을 사용하고, 
중간에 엔티티의 값이 변경되어야 하는 로직은 별도의 비즈니스 메소드를 작성해서 Setter의 사용을 지양하도록 한다.

builder 패턴을 사용할 때는 lombok @Builder를 사용한다. 이 때, @NoArgsConstructor 와 @AllArgsConstructor를 사용한다.
@NoArgsConstructor는 접근 제한을 protected로 걸어서 혹시 모를 빈 객체 생성을 방지한다.

**상속 관계 매핑**  
관계형 데이터베이스에는 상속이라는 개념이 없다. 대신 슈퍼타입 서브타입 관계라는 유사한 모델링 기법이 있다.
슈퍼타입 서브타임 관계를 테이블로 구현할 때는 세 가지 방식을 사용할 수 있다. (다음의 세 가지 전략의 이름은 JPA에서 지칭하는 이름이다.)
- 조인 전략: 각각을 테이블로 만들고 조회할 때 조인한다.
- 단일 테이블 전략: 슈퍼타입 테이블이 서브타입 테이블의 필드를 모두 가진다.
- 구현 클래스마다 테이블 전략: 서브타입 테이블만 만든다. 설계 전문가와 ORM 전문가 모두 추천하지 않는 방식이다.

이 예제에서는 Item을 상속받는 Album, Book, Movie를 구현할 때 단일 테이블 전략을 사용하기로 한다.
단일 테이블 전략에서는 슈퍼타입에 @DiscriminatorColumn(name = "DTYPE") 어노테이션을 사용하여 매핑해주고,
서브타입에는 @DiscriminatorValue("XXX")를 사용해서 매핑한다.
